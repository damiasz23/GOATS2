<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Turniej Koszykówki – Faza Pucharowa</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background: #fafafa; }
    button#refresh { margin-bottom: 10px; padding: 6px 12px; font-size: 1rem; }
    h1 { text-align: center; font-size: 2rem; margin-bottom: 20px; }

    .court-container { display: flex; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    .court { flex: 1; min-width: 320px; }

    table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
    table th, table td { border: 1px solid #ccc; padding: 6px; text-align: center; font-size: 0.9rem; }
    table th { background: #ddd; }

    /* kolorowanie wg płci/mechaniki: róż dla Kobiet, niebieski dla Mężczyzn */
    .women-row { background: rgba(255,182,193,0.3); }
    .men-row   { background: rgba(173,216,230,0.3); }

    td.result-cell { min-width: 50px; }
  </style>
</head>
<body>

  <button id="refresh">Odśwież</button>
  <h1>Faza Pucharowa</h1>

  <div id="app">Ładowanie danych…</div>

<script>
  // —————— KONFIGURACJA ——————
  // THIS MUST BE EXACTLY YOUR POBIERANY LINK Z „Termin​arz_USTALENIA” (kolumny E i K).
  const CSV_URL =
    'https://docs.google.com/spreadsheets/d/e/2PACX-1vRHw8kX-ehVxqRrBxKQRAH9EySHdQUfPwWEae-llcCwEp-ba7-Oh82Llo-8rHCszQFJiKC7SZt8KaVg'
    + '/pub?gid=1242680440&single=true&output=csv';

  // STRUKTURA DRUŻYN z fazy grupowej – potrzebujemy wiedzieć, kto jest 1A,2A,1B,2B
  const TEAMS_GROUP = {
    'Mężczyźni': {
      'A': ['Gdańsk Bukowski Serwis','Kołobrzeg','Rybnik Team','Poznań Biały'],
      'B': ['Zielona Góra','TICINO POLAND','SANICOGOLDLUX','Poznań Niebieski']
    },
    'Kobiety': {
      'A': ['KOBIETY NA BOISKA Łódź','Lejdis Wrocław','Basket Team Gdańsk','Twarde Babki Toruń'],
      'B': ['Chyże Laski Poznań','Warszawa','Rozważne i Romantyczne Rybnik']
    }
  };

  // —————— POBIERANIE WSZYSTKICH WYNIKÓW (POCZĄWSZY OD FAZY GRUPOWEJ) ——————
  async function fetchAllResults() {
    const resp = await fetch(CSV_URL);
    if (!resp.ok) {
      console.error('Błąd podczas pobierania CSV:', resp.status, resp.statusText);
      return [];
    }
    const txt = await resp.text();
    // Każdy wiersz to jedna tura turniejowa: najpierw kolumny A–F (Gruppy A/B wyniki), potem kolumny G–M (kolumny E i K dla pucharu).
    const lines = txt.trim().split(/\r?\n/).slice(1);
    const out = [];

    lines.forEach(line => {
      // CSV jest rozdzielone przecinkami lub średnikami – usuwamy cudzysłowy i trim:
      const cols = line.split(/,|;/).map(c => c.replace(/^"|"$/g,'').trim());

      // Kolumny (indeksy): 
      // 0→A, 1→B, 2→C, 3→D, 4→E, 5→F, 6→G, 7→H, 8→I, 9→J, 10→K, 11→L, 12→M, …
      // Dla *faz pucharowych* nas interesują tylko E (indeks 4) oraz K (indeks 10),
      // ale musimy wiedzieć, kto gra w tych kolumnach:
      //
      // →   E: [2 drużyny w kolumnach C:D] + wynik w E.
      // →   K: [2 drużyny w kolumnach I:J] + wynik w K.
      //
      // Dlatego:
      const teamA_E = cols[1];        // kolumna B w arkuszu: nazwa drużyny (kolumny z lewej fazy pucharowej)
      const teamB_E = cols[3];        // kolumna D w arkuszu: nazwa przeciwnika
      const raw_E   = cols[4];        // kolumna E: wynik „x:y” lub „:”

      const teamA_K = cols[7];        // kolumna H w arkuszu
      const teamB_K = cols[9];        // kolumna J w arkuszu
      const raw_K   = cols[10];       // kolumna K: wynik „x:y” lub „:”

      // Jeżeli w E jest poprawny wynik (nie „:” i nie puste), to dodajemy rekord:
      if (teamA_E && teamB_E && raw_E && raw_E !== ':') {
        out.push({ teamA: teamA_E, teamB: teamB_E, rawScore: raw_E });
      }
      // Jeżeli w K jest poprawny wynik, to dodajemy drugi rekord:
      if (teamA_K && teamB_K && raw_K && raw_K !== ':') {
        out.push({ teamA: teamA_K, teamB: teamB_K, rawScore: raw_K });
      }
    });

    return out;
  }

  // —————— STATYSTYKI FAZY GRUPOWEJ (dzięki którym wiemy, kto jest 1A,2A,1B,2B) ——————
  function computeGroupStats(allResults) {
    // Inicjalizujemy: stats[„Mężczyźni”][„A”][nazwa] = { name, play, pts, for, against, diff }
    const stats = {};
    for (let cat of Object.keys(TEAMS_GROUP)) {
      stats[cat] = {};
      for (let grp of Object.keys(TEAMS_GROUP[cat])) {
        stats[cat][grp] = {};
        TEAMS_GROUP[cat][grp].forEach(name => {
          stats[cat][grp][name] = { name, play: 0, pts: 0, for: 0, against: 0, diff: 0 };
        });
      }
    }
    // Iterujemy po *wszystkich* wynikach („out” z fetchAllResults), ale wpływ mają tylko te, które
    // jednocześnie są w tej samej grupie (np. obie drużyny w listach TEAMS_GROUP[cat][grp]).
    allResults.forEach(r => {
      for (let cat of Object.keys(TEAMS_GROUP)) {
        for (let grp of Object.keys(TEAMS_GROUP[cat])) {
          const list = TEAMS_GROUP[cat][grp];
          if (list.includes(r.teamA) && list.includes(r.teamB)) {
            const [a, b] = r.rawScore.split(':').map(Number);
            // Drużyna A:
            const sA = stats[cat][grp][r.teamA];
            sA.play++;
            sA.for += a;
            sA.against += b;
            sA.diff = sA.for - sA.against;
            sA.pts += (a > b ? 2 : 1);
            // Drużyna B:
            const sB = stats[cat][grp][r.teamB];
            sB.play++;
            sB.for += b;
            sB.against += a;
            sB.diff = sB.for - sB.against;
            sB.pts += (b > a ? 2 : 1);
          }
        }
      }
    });
    return stats;
  }

  // Sortowanie wg 1) pts 2) diff 3) head-to-head 4) nazwa
  function compareTeams(a, b, allResults) {
    if (b.pts !== a.pts) return b.pts - a.pts;
    if (b.diff !== a.diff) return b.diff - a.diff;
    // head-to-head
    const head = allResults.find(x =>
      (x.teamA === a.name && x.teamB === b.name) ||
      (x.teamA === b.name && x.teamB === a.name)
    );
    if (head) {
      const [sa, sb] = head.rawScore.split(':').map(Number);
      if (head.teamA === a.name) {
        if (sa !== sb) return (sa > sb) ? -1 : 1;
      } else {
        if (sb !== sa) return (sb > sa) ? -1 : 1;
      }
    }
    return a.name.localeCompare(b.name);
  }

  // Wyciągamy TOP2 (zwracamy [‘Drużyna1’, ‘Drużyna2’])
  function extractTop2(statsForCategoryGroup, allResults) {
    const arr = Object.values(statsForCategoryGroup);
    arr.sort((x, y) => compareTeams(x, y, allResults));
    return arr.slice(0, 2).map(t => t.name);
  }


  // —————— RENDEROWANIE FAZY PUCHAROWEJ ——————
  async function renderPlayoffs() {
    const app = document.getElementById('app');
    app.innerText = 'Ładowanie danych…';

    // 1) Pobierz WSZYSTKIE wyniki (grupy + puchar) z arkusza:
    const allResults = await fetchAllResults();

    // 2) Oblicz statystyki fazy grupowej:
    const groupStats = computeGroupStats(allResults);

    // 3) Wyciągnij 1A,2A,1B,2B dla każdej kategorii:
    const topA_w = extractTop2(groupStats['Kobiety']['A'], allResults); // [1A_w, 2A_w]
    const topB_w = extractTop2(groupStats['Kobiety']['B'], allResults); // [1B_w, 2B_w]
    const topA_m = extractTop2(groupStats['Mężczyźni']['A'], allResults); // [1A_m, 2A_m]
    const topB_m = extractTop2(groupStats['Mężczyźni']['B'], allResults); // [1B_m, 2B_m]

    // 4) Zbudujmy tablice etapów (kolejność odpowiada wierszom w tabelach):
    //    Boisko A (z lewej strony)
    const PHASES_A = [
      { phase: 'Półfinał Kobiet',   teamA: topA_w[0] || '', teamB: topB_w[1] || '' },
      { phase: 'Półfinał Mężczyzn', teamA: topA_m[0] || '', teamB: topB_m[1] || '' },
      { phase: 'O 7 miejscę',       teamA: '4A',               teamB: '4B'   },
      { phase: 'O 5 miejscę',       teamA: '3A',               teamB: '3B'   },
      { phase: 'O 3 miejscę',       teamA: '1A/2B',            teamB: '1B/2A'},
      { phase: 'Finał Kobiet',      teamA: topA_w[0] || '',    teamB: topB_w[1] || '' },
      { phase: 'Finał Mężczyzn',    teamA: topA_m[0] || '',    teamB: topB_m[1] || '' }
    ];
    //    Boisko B (z prawej strony)
    const PHASES_B = [
      { phase: 'Półfinał Kobiet',   teamA: topB_w[0] || '', teamB: topA_w[1] || '' },
      { phase: 'Półfinał Mężczyzn', teamA: topB_m[0] || '', teamB: topA_m[1] || '' },
      { phase: 'O 7 miejscę',       teamA: '',             teamB: ''        },
      { phase: 'O 5 miejscę',       teamA: '3A',           teamB: '3B'      },
      { phase: 'O 3 miejscę',       teamA: '1A/2B',        teamB: '1B/2A'   },
      { phase: 'Finał Kobiet',      teamA: '',             teamB: ''        },
      { phase: 'Finał Mężczyzn',    teamA: '',             teamB: ''        }
    ];

    // Pomocnicza funkcja do dopasowania wyniku spośród „allResults”:
    function findScore(a, b) {
      if (!a || !b) return '';
      const rec = allResults.find(r =>
        (r.teamA === a && r.teamB === b) ||
        (r.teamA === b && r.teamB === a)
      );
      if (!rec) return '';
      const [x, y] = rec.rawScore.split(':');
      return (rec.teamA === a) ? `${x}:${y}` : `${y}:${x}`;
    }

    // 5) Generowanie HTML dla obu boisk:
    // — Boisko A —
    let htmlA = '<div class="court"><table><thead>'
              + '<tr><th>Godz.</th><th>Faza</th><th>Zespół A</th><th></th><th>Zespół B</th><th>Wynik</th></tr>'
              + '</thead><tbody>';
    const times = ['12:30–13:20','13:20–14:10','14:10–15:00','15:00–15:50','15:50–16:40','17:00–17:50','17:50–18:40'];
    for (let i = 0; i < PHASES_A.length; i++) {
      const p = PHASES_A[i];
      // Kolor wiersza: jeśli faza zawiera „Kobiet” → women-row, jeśli „Mężczyzn” → men-row, w pozostałych
      // placeholderach używamy zgodnie z rysunkiem (co 2 wiersze na zmianę, ale uprościłem: damskie fazy – róż, męskie – niebieski)
      let cls = '';
      if (p.phase.includes('Kobiet')) cls = 'women-row';
      else if (p.phase.includes('Mężczyzn')) cls = 'men-row';
      // Reszta (O 7, O 5, O 3) przyjmuję wg wzoru: co drugi wiersz na zmianę – nie jest kluczowe
      else cls = (i % 2 === 0 ? 'women-row' : 'men-row');

      htmlA += `<tr class="${cls}">`
             + `<td>${times[i]}</td>`
             + `<td>${p.phase}</td>`
             + `<td>${p.teamA}</td>`
             + `<td>vs</td>`
             + `<td>${p.teamB}</td>`
             + `<td class="result-cell">${findScore(p.teamA,p.teamB)}</td>`
             + `</tr>`;
    }
    htmlA += '</tbody></table></div>';

    // — Boisko B —
    let htmlB = '<div class="court"><table><thead>'
              + '<tr><th>Godz.</th><th>Faza</th><th>Zespół A</th><th></th><th>Zespół B</th><th>Wynik</th></tr>'
              + '</thead><tbody>';
    for (let i = 0; i < PHASES_B.length; i++) {
      const p = PHASES_B[i];
      let cls = '';
      if (p.phase.includes('Kobiet')) cls = 'women-row';
      else if (p.phase.includes('Mężczyzn')) cls = 'men-row';
      else cls = (i % 2 === 0 ? 'women-row' : 'men-row');

      htmlB += `<tr class="${cls}">`
             + `<td>${times[i]}</td>`
             + `<td>${p.phase}</td>`
             + `<td>${p.teamA}</td>`
             + `<td>vs</td>`
             + `<td>${p.teamB}</td>`
             + `<td class="result-cell">${findScore(p.teamA,p.teamB)}</td>`
             + `</tr>`;
    }
    htmlB += '</tbody></table></div>';

    // 6) Wstawiamy finalne HTML do kontenera:
    app.innerHTML = `<div class="court-container">${htmlA}${htmlB}</div>`;
  }

  // Obsługa przycisku „Odśwież”
  document.getElementById('refresh').addEventListener('click', renderPlayoffs);

  // Automatyczne odświeżanie co 3 minuty (180 000 ms)
  setInterval(renderPlayoffs, 180000);

  // Pierwsze wywołanie
  renderPlayoffs();
</script>
</body>
</html>
