<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Turniej – Faza Pucharowa</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background: #fafafa; }
    button#refresh { margin-bottom: 10px; padding: 6px 12px; font-size: 1rem; }
    .bracket-container { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 20px; }
    .court { flex: 1; }
    .court h2 { text-align: center; margin-bottom: 10px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: center; }
    th { background: #ddd; }
    tr.phase td { background: #eee; font-weight: bold; }
    tr.women td { background: rgba(255,182,193,0.3); }
    tr.men td   { background: rgba(173,216,230,0.3); }
    tr.break td { background: #f0f0f0; font-weight: bold; }
    .finals { margin-top: 10px; }
    .finals table { width: 100%; }
    .finals th, .finals td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    .finals th { background: #ddd; }
  </style>
</head>
<body>
  <button id="refresh">Odśwież</button>
  <h1 style="text-align:center;">Faza Pucharowa</h1>
  <div id="brackets" class="bracket-container">
    <!-- Boisko A -->
    <div class="court" id="court-A">
      <h2>Boisko A</h2>
      <table>
        <thead>
          <tr><th>Godz.</th><th>Faza</th><th>Zespół A</th><th></th><th>Zespół B</th><th>Wynik</th></tr>
        </thead>
        <tbody id="court-A-body">
          <tr><td colspan="6">Ładowanie...</td></tr>
        </tbody>
      </table>
    </div>

    <!-- Boisko B -->
    <div class="court" id="court-B">
      <h2>Boisko B</h2>
      <table>
        <thead>
          <tr><th>Godz.</th><th>Faza</th><th>Zespół A</th><th></th><th>Zespół B</th><th>Wynik</th></tr>
        </thead>
        <tbody id="court-B-body">
          <tr><td colspan="6">Ładowanie...</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Finały sekcja -->
  <div class="finals">
    <table>
      <thead>
        <tr><th>Godz.</th><th>Faza</th><th>Zespół A</th><th></th><th>Zespół B</th><th>Wynik</th></tr>
      </thead>
      <tbody id="finals-body">
        <tr><td colspan="6">Ładowanie...</td></tr>
      </tbody>
    </table>
  </div>

  <script>
    // co ile ms automatycznie odświeżać:
    const REFRESH_MS = 180000; // 180 000 ms = 3 minuty

    // URL do CSV z arkusza – pisz dokładnie ten, w którym są kolumny E i K na fazę pucharową
    const CSV_URL =
      'https://docs.google.com/spreadsheets/d/e/2PACX-1vRHw8kX-ehVxqRrBxKQRAH9EySHdQUfPwWEae-llcCwEp-ba7-Oh82Llo-8rHCszQFJiKC7SZt8KaVg'
      + '/pub?gid=1242680440&single=true&output=csv';

    // Zespoły z grup (te same, co w fazie grupowej). Potrzebne, aby wytypować, kto gra w półfinale.
    const TEAMS = {
      'Mężczyźni': {
        A: ['Gdańsk Bukowski Serwis','Kołobrzeg','Rybnik Team','Poznań Biały'],
        B: ['Zielona Góra','TICINO POLAND','SANICOGOLDLUX','Poznań Niebieski']
      },
      'Kobiety': {
        A: ['KOBIETY NA BOISKA Łódź','Lejdis Wrocław','Basket Team Gdańsk','Twarde Babki Toruń'],
        B: ['Chyże Laski Poznań','Warszawa','Rozważne i Romantyczne Rybnik']
      }
    };

    // Trzyma wszystkie pobrane mecze (zarówno grupowe, jak i pucharowe)
    let allResults = [];

    /**
     * Pobiera CSV, dzieli na linie, 
     * a następnie filtruje wyłącznie te wiersze, w których kolumna E lub K zawiera prawdziwy rezultat "X:Y" (gdzie X,Y to cyfry).
     * Zwraca tablicę obiektów typu { teamA, teamB, raw }.
     */
    async function fetchResults() {
      const response = await fetch(CSV_URL);
      const text = await response.text();
      const lines = text.trim().split(/\r?\n/);

      const arr = [];
      lines.forEach((line, idx) => {
        if (idx === 0) return; // pomiń nagłówek CSV
        const cols = line.split(/,|;/).map(cell => cell.replace(/^"|"$/g, '').trim());
        // Kolumna E → indeks 4, Kolumna K → indeks 10
        const tA = cols[1],   // nazwa drużyny A (boisko A)
              tB = cols[3],   // nazwa drużyny B (boisko A)
              rawA = cols[4], // wynik „X:Y” w boisko A
              tC = cols[7],   // nazwa drużyny A (boisko B)
              tD = cols[9],   // nazwa drużyny B (boisko B)
              rawB = cols[10]; // wynik „X:Y” w boisko B

        // jeśli rawA ma format „cyfra:cyfra”, traktujemy jako mecz boisko A
        if (/^\d+:\d+$/.test(rawA) && tA && tB) {
          arr.push({ teamA: tA, teamB: tB, raw: rawA });
        }
        // jeśli rawB ma format „cyfra:cyfra”, traktujemy jako mecz boisko B
        if (/^\d+:\d+$/.test(rawB) && tC && tD) {
          arr.push({ teamA: tC, teamB: tD, raw: rawB });
        }
      });

      allResults = arr;
      return arr;
    }

    /**
     * Tworzy początkową strukturę do liczenia punktów i różnicy w fazie grupowej.
     * Nie liczymy tutaj meczów pucharowych – tylko te wyniki służą do wytypowania półfinalistów.
     */
    function initStats() {
      const stats = {};
      for (const cat in TEAMS) {
        stats[cat] = {};
        for (const grp in TEAMS[cat]) {
          // Tablica obiektów { name, pts, diff }
          stats[cat][grp] = TEAMS[cat][grp].map(name => ({ name, pts: 0, diff: 0 }));
        }
      }
      return stats;
    }

    /**
     * Na podstawie wszytkich meczów (group + playoff) liczy statystyki tylko dla fazy grupowej.
     * W fazie grupowej: za zwycięstwo X:Y (X>Y) → 2 punkty, za porażkę → 1 pkt. Różnica punktowa to sumy “for − against”.
     */
    function computeStats(results) {
      const stats = initStats();
      results.forEach(r => {
        for (const cat in TEAMS) {
          for (const grp in TEAMS[cat]) {
            const teamList = TEAMS[cat][grp];
            if (teamList.includes(r.teamA) && teamList.includes(r.teamB)) {
              const [a, b] = r.raw.split(':').map(Number);
              const A = stats[cat][grp].find(x => x.name === r.teamA);
              const B = stats[cat][grp].find(x => x.name === r.teamB);
              if (A && B) {
                // przydziel punkty
                A.pts += (a > b ? 2 : 1);
                B.pts += (b > a ? 2 : 1);
                // przydziel różnicę
                A.diff += (a - b);
                B.diff += (b - a);
              }
            }
          }
        }
      });
      return stats;
    }

    /**
     * Sortuje zespoły wg:
     *   1) pkt (malejąco),
     *   2) diff (malejąco),
     *   3) nazwa (alfabetycznie),
     * żeby wytypować kolejność w grupie.
     */
    function sortTeams(arr) {
      return arr.sort((a, b) => {
        if (b.pts !== a.pts) return b.pts - a.pts;
        if (b.diff !== a.diff) return b.diff - a.diff;
        return a.name.localeCompare(b.name);
      });
    }

    /**
     * Zwraca “X:Y” w takim układzie, aby odpowiadał kolejności (teamX vs. teamY).
     * Jeśli w allResults mecz A:B występuje w zapisie “B:A:raw”, odwracamy.
     * Jeśli meczu nie ma lub nie znaleziono jeszcze wyniku, zwraca “:”.
     */
    function findScore(teamX, teamY) {
      const match = allResults.find(r =>
        (r.teamA === teamX && r.teamB === teamY) ||
        (r.teamA === teamY && r.teamB === teamX)
      );
      if (!match) return ':';
      const [a, b] = match.raw.split(':').map(Number);
      return (match.teamA === teamX) ? `${a}:${b}` : `${b}:${a}`;
    }

    /**
     * Generuje kolejne wiersze tabeli (Boisko A, Boisko B, Finały) na podstawie tego,
     * jacy półfinaliści wyłonili się wg statystyk grupowych.
     */
    function populateCourts(stats) {
      // posortowane tablice (kobiety A/B i mężczyźni A/B)
      const wA_sorted = sortTeams([...stats['Kobiety']['A']]);
      const wB_sorted = sortTeams([...stats['Kobiety']['B']]);
      const mA_sorted = sortTeams([...stats['Mężczyźni']['A']]);
      const mB_sorted = sortTeams([...stats['Mężczyźni']['B']]);

      // półfinaliści (kobiety)
      const wSF_A = (wA_sorted[0]?.pts > 0) ? wA_sorted[0].name : '1A';
      const wSF_B = (wB_sorted[1]?.pts > 0) ? wB_sorted[1].name : '2B';
      const wSF_C = (wB_sorted[0]?.pts > 0) ? wB_sorted[0].name : '1B';
      const wSF_D = (wA_sorted[1]?.pts > 0) ? wA_sorted[1].name : '2A';

      // półfinaliści (mężczyźni)
      const mSF_A = (mA_sorted[0]?.pts > 0) ? mA_sorted[0].name : '1A';
      const mSF_B = (mB_sorted[1]?.pts > 0) ? mB_sorted[1].name : '2B';
      const mSF_C = (mB_sorted[0]?.pts > 0) ? mB_sorted[0].name : '1B';
      const mSF_D = (mA_sorted[1]?.pts > 0) ? mA_sorted[1].name : '2A';

      // miejsca 7./5./3. (placeholdery)
      const p7_A = '4A', p7_B = '4B';
      const p5_A = '3A', p5_B = '3B';
      const p3_A = '1A/2B', p3_B = '1B/2A';

      // wiersze dla Boiska A
      const rowsA = [
        { time:'12:30-13:20', phase:'Półfinał Kobiet',   teamA:wSF_A, teamB:wSF_B, cls:'women' },
        { time:'13:20-14:10', phase:'Półfinał Mężczyzn', teamA:mSF_A, teamB:mSF_B, cls:'men'   },
        { time:'14:10-15:00', phase:'O 7 miejsce',       teamA:p7_A,   teamB:p7_B,   cls:'women' },
        { time:'15:00-15:50', phase:'O 5 miejsce',       teamA:p5_A,   teamB:p5_B,   cls:'men'   },
        { time:'15:50-16:40', phase:'O 3 miejsce',       teamA:p3_A,   teamB:p3_B,   cls:'women' },
        { time:'break',      phase:'PRZERWA TECHNICZNA' }
      ];

      // wiersze dla Boiska B
      const rowsB = [
        { time:'12:30-13:20', phase:'Półfinał Kobiet',   teamA:wSF_C, teamB:wSF_D, cls:'women' },
        { time:'13:20-14:10', phase:'Półfinał Mężczyzn', teamA:mSF_C, teamB:mSF_D, cls:'men'   },
        { time:'14:10-15:00', phase:'O 5 miejsce',       teamA:p5_A,   teamB:p5_B,   cls:'women' },
        { time:'15:00-15:50', phase:'O 3 miejsce',       teamA:p3_A,   teamB:p3_B,   cls:'men'   },
        { time:'break',      phase:'PRZERWA TECHNICZNA' }
      ];

      // wiersze finałów
      const finalRows = [
        { time:'17:00-17:50', phase:'Finał Kobiet',      teamA:wSF_A, teamB:wSF_B, cls:'women' },
        { time:'17:50-18:40', phase:'Finał Mężczyzn',    teamA:mSF_A, teamB:mSF_B, cls:'men'   }
      ];

      // render Boisko A
      let htmlA = '';
      rowsA.forEach(r => {
        if (r.time === 'break') {
          htmlA += `<tr class="break"><td colspan="6">${r.phase}</td></tr>`;
        } else {
          const score = findScore(r.teamA, r.teamB);
          htmlA += `<tr class="phase"><td>${r.time}</td><td colspan="4">${r.phase}</td><td></td></tr>`;
          htmlA += `<tr class="${r.cls}"><td></td><td></td><td>${r.teamA}</td><td>vs</td><td>${r.teamB}</td><td>${score}</td></tr>`;
        }
      });
      document.getElementById('court-A-body').innerHTML = htmlA;

      // render Boisko B
      let htmlB = '';
      rowsB.forEach(r => {
        if (r.time === 'break') {
          htmlB += `<tr class="break"><td colspan="6">${r.phase}</td></tr>`;
        } else {
          const score = findScore(r.teamA, r.teamB);
          htmlB += `<tr class="phase"><td>${r.time}</td><td colspan="4">${r.phase}</td><td></td></tr>`;
          htmlB += `<tr class="${r.cls}"><td></td><td></td><td>${r.teamA}</td><td>vs</td><td>${r.teamB}</td><td>${score}</td></tr>`;
        }
      });
      document.getElementById('court-B-body').innerHTML = htmlB;

      // render Finałów
      let htmlF = '';
      finalRows.forEach(r => {
        const score = findScore(r.teamA, r.teamB);
        htmlF += `<tr class="phase"><td>${r.time}</td><td colspan="4">${r.phase}</td><td></td></tr>`;
        htmlF += `<tr class="${r.cls}"><td></td><td></td><td>${r.teamA}</td><td>vs</td><td>${r.teamB}</td><td>${score}</td></tr>`;
      });
      document.getElementById('finals-body').innerHTML = htmlF;
    }

    /**
     * Główna funkcja: 1) wyczyść placeholdery, 2) pobierz wyniki CSV → allResults, 
     * 3) oblicz statystyki fazy grupowej, 4) uzupełnij tabele fazy pucharowej,
     * 5) po 3 min odśwież sam siebie ponownie.
     */
    async function init() {
      document.getElementById('court-A-body').innerHTML = '<tr><td colspan="6">Ładowanie...</td></tr>';
      document.getElementById('court-B-body').innerHTML = '<tr><td colspan="6">Ładowanie...</td></tr>';
      document.getElementById('finals-body').innerHTML = '<tr><td colspan="6">Ładowanie...</td></tr>';
      await fetchResults();
      const stats = computeStats(allResults);
      populateCourts(stats);
      setTimeout(init, REFRESH_MS);
    }

    document.getElementById('refresh').addEventListener('click', init);
    init();
  </script>
</body>
</html>
