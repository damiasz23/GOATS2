<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Turniej ‚Äì Faza Pucharowa</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background: #fafafa; }
    button#refresh { margin-bottom: 10px; padding: 6px 12px; font-size: 1rem; }
    .bracket-container { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 20px; }
    .court { flex: 1; }
    .court h2 { text-align: center; margin-bottom: 10px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: center; }
    th { background: #ddd; }
    /* faza (nag≈Ç√≥wki) */
    tr.phase td { background: #eee; font-weight: bold; }
    /* wiersze "kobiece" */
    tr.women td { background: rgba(255,182,193,0.3); }
    /* wiersze "mƒôskie" */
    tr.men td   { background: rgba(173,216,230,0.3); }
    /* przerwa techniczna */
    tr.break td { background: #f0f0f0; font-weight: bold; }
    .finals { margin-top: 10px; }
    .finals table { width: 100%; }
    .finals th, .finals td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    .finals th { background: #ddd; }
  </style>
</head>
<body>
  <button id="refresh">Od≈õwie≈º</button>
  <h1 style="text-align:center;">Faza Pucharowa</h1>

  <div id="brackets" class="bracket-container">
    <!-- Boisko A -->
    <div class="court" id="court-A">
      <h2>Boisko A</h2>
      <table>
        <thead>
          <tr>
            <th>Godz.</th><th>Faza</th><th>Zesp√≥≈Ç A</th><th></th><th>Zesp√≥≈Ç B</th><th>Wynik</th>
          </tr>
        </thead>
        <tbody id="court-A-body">
          <tr><td colspan="6">≈Åadowanie...</td></tr>
        </tbody>
      </table>
    </div>

    <!-- Boisko B -->
    <div class="court" id="court-B">
      <h2>Boisko B</h2>
      <table>
        <thead>
          <tr>
            <th>Godz.</th><th>Faza</th><th>Zesp√≥≈Ç A</th><th></th><th>Zesp√≥≈Ç B</th><th>Wynik</th>
          </tr>
        </thead>
        <tbody id="court-B-body">
          <tr><td colspan="6">≈Åadowanie...</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Fina≈Çy sekcja -->
  <div class="finals">
    <table>
      <thead>
        <tr>
          <th>Godz.</th><th>Faza</th><th>Zesp√≥≈Ç A</th><th></th><th>Zesp√≥≈Ç B</th><th>Wynik</th>
        </tr>
      </thead>
      <tbody id="finals-body">
        <tr><td colspan="6">≈Åadowanie...</td></tr>
      </tbody>
    </table>
  </div>

<script>
  // co ile ms automatycznie od≈õwie≈ºaƒá aplikacjƒô:
  const REFRESH_MS = 180000; // = 3 minuty

  // Adres publikowany jako CSV: musi zawieraƒá kolumny E i K dla fazy pucharowej
  const CSV_URL =
    'https://docs.google.com/spreadsheets/d/e/2PACX-1vRHw8kX-ehVxqRrBxKQRAH9EySHdQUfPwWEae-llcCwEp-ba7-Oh82Llo-8rHCszQFJiKC7SZt8KaVg'
    + '/pub?gid=1242680440&single=true&output=csv';

  // Definicja dru≈ºyn w grupach (ta sama jak w aplikacji fazy grupowej)
  const TEAMS = {
    'Mƒô≈ºczy≈∫ni': {
      A: ['Gda≈Ñsk Bukowski Serwis','Ko≈Çobrzeg','Rybnik Team','Pozna≈Ñ Bia≈Çy'],
      B: ['Zielona G√≥ra','TICINO POLAND','SANICOGOLDLUX','Pozna≈Ñ Niebieski']
    },
    'Kobiety': {
      A: ['KOBIETY NA BOISKA ≈Å√≥d≈∫','Lejdis Wroc≈Çaw','Basket Team Gda≈Ñsk','Twarde Babki Toru≈Ñ'],
      B: ['Chy≈ºe Laski Pozna≈Ñ','Warszawa','Rozwa≈ºne i Romantyczne Rybnik']
    }
  };

  // Tutaj przechowujemy WSZYSTKIE wyniki (zar√≥wno grupowe, jak i pucharowe)
  let allResults = [];

  /**
   * 1) Pobiera CSV ‚Üí 2) dzieli linie po \n ‚Üí 3) parsuje ka≈ºdƒÖ liniƒô
   * 4) Dok≈Çadnie z kolumn E (indeks 4) i K (indeks 10) wyciƒÖga "X:Y".
   *     - Je≈õli w tej kolumnie jest dok≈Çadnie "liczba:liczba" ‚Üí dodaje do allResults.
   * 5) Zwraca tablicƒô obiekt√≥w: { teamA:"nazwaA", teamB:"nazwaB", raw:"X:Y" }.
   */
  async function fetchResults() {
    const response = await fetch(CSV_URL);
    const text = await response.text();
    const lines = text.trim().split(/\r?\n/);

    const arr = [];
    lines.forEach((line, idx) => {
      if (idx === 0) return; // pomijamy nag≈Ç√≥wek CSV
      // Rozbijamy po przecinku lub ≈õredniku, usuwamy ewentualne cudzys≈Çowy i bia≈Çe znaki
      const cols = line.split(/,|;/).map(cell => cell.replace(/^"|"$/g,'').trim());

      // --- Boisko A ---
      const tA   = cols[1];    // nazwa dru≈ºyny A na boisku A
      const tB   = cols[3];    // nazwa dru≈ºyny B na boisku A
      const rawA = cols[4];    // wynik w kolumnie E (boisko A)

      // --- Boisko B ---
      const tC   = cols[7];    // nazwa dru≈ºyny A na boisku B
      const tD   = cols[9];    // nazwa dru≈ºyny B na boisku B
      const rawB = cols[10];   // wynik w kolumnie K (boisko B)

      // Je≈ºeli rawA to dok≈Çadnie "cyfra:cyfra", dodajemy wpis {teamA, teamB, raw:rawA}
      if (/^\d+:\d+$/.test(rawA) && tA && tB) {
        arr.push({ teamA: tA, teamB: tB, raw: rawA });
      }
      // Je≈ºeli rawB to dok≈Çadnie "cyfra:cyfra", to dodajemy dla boiska B
      if (/^\d+:\d+$/.test(rawB) && tC && tD) {
        arr.push({ teamA: tC, teamB: tD, raw: rawB });
      }
    });

    allResults = arr;
    return arr;
  }

  /**
   * Tworzy strukturƒô potrzebnƒÖ do liczenia statystyk fazy grupowej.
   * Nie bierzemy tu pod uwagƒô mecz√≥w pucharowych ‚Äî one s≈Çu≈ºƒÖ tylko do wytypowania p√≥≈Çfinalist√≥w.
   * Format zwracanej struktury:
   *   {
   *     "Mƒô≈ºczy≈∫ni": {
   *       "A": [ {name:"Gda≈Ñsk Bukowski Serwis",pts:0,diff:0}, {...}, ... ],
   *       "B": [ {...}, ... ]
   *     },
   *     "Kobiety": { "A":[...], "B":[...] }
   *   }
   */
  function initStats() {
    const stats = {};
    for (const cat in TEAMS) {
      stats[cat] = {};
      for (const grp in TEAMS[cat]) {
        stats[cat][grp] = TEAMS[cat][grp].map(name => ({
          name, pts: 0, diff: 0
        }));
      }
    }
    return stats;
  }

  /**
   * Przechodzi po WSZYSTKICH wynikach w allResults (grupy + playoffs),
   * ale aktualizuje tylko te mecze, kt√≥re wystƒôpujƒÖ w fazie grupowej.
   * Za zwyciƒôstwo w grupie (np. "33:23") przyznajemy:
   *   je≈õli a>b ‚Üí 2 punkty dla A, 1 punkt dla B
   *   je≈õli b>a ‚Üí 2 punkty dla B, 1 punkt dla A
   * i aktualizujemy te≈º r√≥≈ºnicƒô punktowƒÖ (diff = for ‚àí against).
   */
  function computeStats(results) {
    const stats = initStats();
    results.forEach(r => {
      for (const cat in TEAMS) {
        for (const grp in TEAMS[cat]) {
          const teamList = TEAMS[cat][grp];
          if (teamList.includes(r.teamA) && teamList.includes(r.teamB)) {
            const [a, b] = r.raw.split(':').map(Number);
            const A = stats[cat][grp].find(x => x.name === r.teamA);
            const B = stats[cat][grp].find(x => x.name === r.teamB);
            if (A && B) {
              // przydziel punkty
              if (a > b) {
                A.pts += 2;
                B.pts += 1;
              } else {
                B.pts += 2;
                A.pts += 1;
              }
              // przydziel r√≥≈ºnicƒô
              A.diff += (a - b);
              B.diff += (b - a);
            }
          }
        }
      }
    });
    return stats;
  }

  /**
   * Sortowanie zespo≈Ç√≥w w grupie wg:
   *   1) punkt√≥w (malejƒÖco),
   *   2) r√≥≈ºnicy punktowej (malejƒÖco),
   *   3) alfabetycznie po nazwie.
   */
  function sortTeams(arr) {
    return arr.sort((a, b) => {
      if (b.pts !== a.pts) return b.pts - a.pts;
      if (b.diff !== a.diff) return b.diff - a.diff;
      return a.name.localeCompare(b.name);
    });
  }

  /**
   * Funkcja pomocnicza: znajduje w allResults wynik meczu miƒôdzy teamX a teamY,
   * niezale≈ºnie od kolejno≈õci (czyli je≈õli w CSV jest {teamA:"1A",teamB:"2B"}, 
   * to findScore("2B","1A") te≈º zwr√≥ci "wynik"). Je≈õli nie ma jeszcze wyniku zwr√≥ci ":".
   */
  function findScore(teamX, teamY) {
    const match = allResults.find(r =>
      (r.teamA === teamX && r.teamB === teamY) ||
      (r.teamA === teamY && r.teamB === teamX)
    );
    if (!match) return ':';
    const [x, y] = match.raw.split(':').map(Number);
    return (match.teamA === teamX) ? `${x}:${y}` : `${y}:${x}`;
  }

  /**
   * Na podstawie statystyk fazy grupowej (pts i diff) wybiera p√≥≈Çfinalist√≥w
   * (zapisanych w postaci placeholder√≥w "1A","2B" itd.), a p√≥≈∫niej generuje wiersze
   * tabeli ze wszystkimi fazami (P√≥≈Çfina≈Çy / O 7 / O 5 / O 3 / i Fina≈Çy) oraz wrzuca
   * do <tbody> odpowiedni HTML.
   *
   * Wa≈ºne: do wy≈õwietlania wyniku zawsze u≈ºywamy placeholder√≥w ("1A", "2B") przy findScore,
   * bo CSV pucharowe przechowuje w≈Ça≈õnie mecze opisane placeholderami, a nie faktycznymi nazwami.
   */
  function populateCourts(stats) {
    // üëâ 1) Sortujemy zespo≈Çy w ka≈ºdej grupie:
    const wA_sorted = sortTeams([...stats['Kobiety']['A']]);
    const wB_sorted = sortTeams([...stats['Kobiety']['B']]);
    const mA_sorted = sortTeams([...stats['Mƒô≈ºczy≈∫ni']['A']]);
    const mB_sorted = sortTeams([...stats['Mƒô≈ºczy≈∫ni']['B']]);

    // üëâ 2) WyciƒÖgamy z sortowania: faktyczne nazwy (gdzie mamy ju≈º rozegrane mecze)
    //    albo placeholder (gdy dane nie sƒÖ jeszcze w allResults).
    //    Przyk≈Çad: je≈õli w grupie Kobiet A mamy zwyciƒôzcƒô "KOBIETY NA BOISKA ≈Å√≥d≈∫",
    //    to wSF_A bƒôdzie "KOBIETY NA BOISKA ≈Å√≥d≈∫", a placeholder_pfA = "1A".
    //    Je≈õli za≈õ ta dru≈ºyna nie ma punkt√≥w (mecz nie rozegrany), placeholder_pfA = "1A",
    //    natomiast name_pfA = "1A" (to jest placeholder zamiast prawdziwej nazwy).
    //
    // Kobiety - p√≥≈Çfina≈Çy
    const wSF_A_ph = '1A',               // zawsze placeholder numer 1A
          wSF_B_ph = '2B',               // placeholder 2B
          wSF_C_ph = '1B',               // placeholder 1B
          wSF_D_ph = '2A';               // placeholder 2A

    const wSF_A_name = (wA_sorted[0]?.pts > 0) ? wA_sorted[0].name : wSF_A_ph;
    const wSF_B_name = (wB_sorted[1]?.pts > 0) ? wB_sorted[1].name : wSF_B_ph;
    const wSF_C_name = (wB_sorted[0]?.pts > 0) ? wB_sorted[0].name : wSF_C_ph;
    const wSF_D_name = (wA_sorted[1]?.pts > 0) ? wA_sorted[1].name : wSF_D_ph;

    // Mƒô≈ºczy≈∫ni - p√≥≈Çfina≈Çy
    const mSF_A_ph = '1A',
          mSF_B_ph = '2B',
          mSF_C_ph = '1B',
          mSF_D_ph = '2A';

    const mSF_A_name = (mA_sorted[0]?.pts > 0) ? mA_sorted[0].name : mSF_A_ph;
    const mSF_B_name = (mB_sorted[1]?.pts > 0) ? mB_sorted[1].name : mSF_B_ph;
    const mSF_C_name = (mB_sorted[0]?.pts > 0) ? mB_sorted[0].name : mSF_C_ph;
    const mSF_D_name = (mA_sorted[1]?.pts > 0) ? mA_sorted[1].name : mSF_D_ph;

    // --------‚Äì PLACEHOLDERY do pozosta≈Çych faz (jeszcze brak wynik√≥w) --------
    const p7_A_ph = '4A',    p7_B_ph = '4B';
    const p5_A_ph = '3A',    p5_B_ph = '3B';
    const p3_A_ph = '1A/2B', p3_B_ph = '1B/2A';

    // -------- Boisko A: budujemy tablicƒô wierszy (ka≈ºdy element to obiekt z danymi) --------
    const rowsA = [
      // p√≥≈Çfina≈Ç kobiet
      {
        time:  '12:30-13:20',
        phase: 'P√≥≈Çfina≈Ç Kobiet',
        phA:   wSF_A_ph,      // placeholder "1A"
        phB:   wSF_B_ph,      // placeholder "2B"
        nameA: wSF_A_name,    // faktyczna nazwa lub "1A"
        nameB: wSF_B_name,    // faktyczna nazwa lub "2B"
        cls:   'women'
      },
      // p√≥≈Çfina≈Ç mƒô≈ºczyzn
      {
        time:  '13:20-14:10',
        phase: 'P√≥≈Çfina≈Ç Mƒô≈ºczyzn',
        phA:   mSF_A_ph,
        phB:   mSF_B_ph,
        nameA: mSF_A_name,
        nameB: mSF_B_name,
        cls:   'men'
      },
      // mecz o 7. miejsce (jeszcze placeholdery)
      {
        time:  '14:10-15:00',
        phase: 'O 7 miejsce',
        phA:   p7_A_ph,
        phB:   p7_B_ph,
        nameA: p7_A_ph,
        nameB: p7_B_ph,
        cls:   'women'
      },
      // mecz o 5. miejsce
      {
        time:  '15:00-15:50',
        phase: 'O 5 miejsce',
        phA:   p5_A_ph,
        phB:   p5_B_ph,
        nameA: p5_A_ph,
        nameB: p5_B_ph,
        cls:   'men'
      },
      // mecz o 3. miejsce
      {
        time:  '15:50-16:40',
        phase: 'O 3 miejsce',
        phA:   p3_A_ph,
        phB:   p3_B_ph,
        nameA: p3_A_ph,
        nameB: p3_B_ph,
        cls:   'women'
      },
      // przerwa techniczna (tu nie ma kolumn z dru≈ºynami)
      {
        time:  'break',
        phase: 'PRZERWA TECHNICZNA'
      }
    ];

    // -------- Boisko B: analogicznie --------
    const rowsB = [
      // p√≥≈Çfina≈Ç kobiet (drugi p√≥≈Çfina≈Ç)
      {
        time:  '12:30-13:20',
        phase: 'P√≥≈Çfina≈Ç Kobiet',
        phA:   wSF_C_ph,
        phB:   wSF_D_ph,
        nameA: wSF_C_name,
        nameB: wSF_D_name,
        cls:   'women'
      },
      // p√≥≈Çfina≈Ç mƒô≈ºczyzn
      {
        time:  '13:20-14:10',
        phase: 'P√≥≈Çfina≈Ç Mƒô≈ºczyzn',
        phA:   mSF_C_ph,
        phB:   mSF_D_ph,
        nameA: mSF_C_name,
        nameB: mSF_D_name,
        cls:   'men'
      },
      // mecz o 5. miejsce (kobiety)
      {
        time:  '14:10-15:00',
        phase: 'O 5 miejsce',
        phA:   p5_A_ph,
        phB:   p5_B_ph,
        nameA: p5_A_ph,
        nameB: p5_B_ph,
        cls:   'women'
      },
      // mecz o 3. miejsce (mƒô≈ºczy≈∫ni)
      {
        time:  '15:00-15:50',
        phase: 'O 3 miejsce',
        phA:   p3_A_ph,
        phB:   p3_B_ph,
        nameA: p3_A_ph,
        nameB: p3_B_ph,
        cls:   'men'
      },
      // przerwa techniczna
      {
        time:  'break',
        phase: 'PRZERWA TECHNICZNA'
      }
    ];

    // -------- Fina≈Çy: (kobiety ‚Üí 17:00-17:50; mƒô≈ºczy≈∫ni ‚Üí 17:50-18:40) --------
    const finalRows = [
      {
        time:  '17:00-17:50',
        phase: 'Fina≈Ç Kobiet',
        phA:   wSF_A_ph,
        phB:   wSF_B_ph,
        nameA: wSF_A_name,
        nameB: wSF_B_name,
        cls:   'women'
      },
      {
        time:  '17:50-18:40',
        phase: 'Fina≈Ç Mƒô≈ºczyzn',
        phA:   mSF_A_ph,
        phB:   mSF_B_ph,
        nameA: mSF_A_name,
        nameB: mSF_B_name,
        cls:   'men'
      }
    ];

    // -------------------------------------------------------------------------
    //  Teraz wypisujemy te wiersze do konkretnych <tbody> w HTML:
    // -------------------------------------------------------------------------

    // --- Boisko A ---
    let htmlA = '';
    rowsA.forEach(r => {
      if (r.time === 'break') {
        htmlA += `<tr class="break"><td colspan="6">${r.phase}</td></tr>`;
      } else {
        // je≈ºeli to normalny mecz, szukamy wyniku po placeholderach
        const score = findScore(r.phA, r.phB);
        htmlA += `
          <tr class="phase">
            <td>${r.time}</td>
            <td colspan="4">${r.phase}</td>
            <td></td>
          </tr>
          <tr class="${r.cls}">
            <td></td><td></td>
            <td>${r.nameA}</td>
            <td>vs</td>
            <td>${r.nameB}</td>
            <td>${score}</td>
          </tr>
        `;
      }
    });
    document.getElementById('court-A-body').innerHTML = htmlA;


    // --- Boisko B ---
    let htmlB = '';
    rowsB.forEach(r => {
      if (r.time === 'break') {
        htmlB += `<tr class="break"><td colspan="6">${r.phase}</td></tr>`;
      } else {
        const score = findScore(r.phA, r.phB);
        htmlB += `
          <tr class="phase">
            <td>${r.time}</td>
            <td colspan="4">${r.phase}</td>
            <td></td>
          </tr>
          <tr class="${r.cls}">
            <td></td><td></td>
            <td>${r.nameA}</td>
            <td>vs</td>
            <td>${r.nameB}</td>
            <td>${score}</td>
          </tr>
        `;
      }
    });
    document.getElementById('court-B-body').innerHTML = htmlB;


    // --- Fina≈Çy ---
    let htmlF = '';
    finalRows.forEach(r => {
      const score = findScore(r.phA, r.phB);
      htmlF += `
        <tr class="phase">
          <td>${r.time}</td>
          <td colspan="4">${r.phase}</td>
          <td></td>
        </tr>
        <tr class="${r.cls}">
          <td></td><td></td>
          <td>${r.nameA}</td>
          <td>vs</td>
          <td>${r.nameB}</td>
          <td>${score}</td>
        </tr>
      `;
    });
    document.getElementById('finals-body').innerHTML = htmlF;
  }

  /**
   * G≈Ç√≥wna funkcja:
   *   1) zeruje placeholdery w tabelach,
   *   2) pobiera wyniki (fetchResults),
   *   3) liczy statystyki grupowe (computeStats),
   *   4) generuje widok fazy pucharowej (populateCourts),
   *   5) po REFRESH_MS ms uruchamia siƒô ponownie (pƒôtla autood≈õwie≈ºania).
   */
  async function init() {
    // 1) Wyczy≈õƒá placeholdery
    document.getElementById('court-A-body').innerHTML = '<tr><td colspan="6">≈Åadowanie...</td></tr>';
    document.getElementById('court-B-body').innerHTML = '<tr><td colspan="6">≈Åadowanie...</td></tr>';
    document.getElementById('finals-body').innerHTML   = '<tr><td colspan="6">≈Åadowanie...</td></tr>';

    // 2) Pobierz CSV do allResults
    await fetchResults();

    // 3) Oblicz statystyki grupowe (na podstawie wszystkich wynik√≥w, ale uwzglƒôdniamy tylko te spo≈õr√≥d them, kt√≥re nale≈ºƒÖ do grup)
    const stats = computeStats(allResults);

    // 4) Wype≈Çnij tabele fazy pucharowej na podstawie placeholder√≥w i statystyk
    populateCourts(stats);

    // 5) Ustaw od≈õwie≈ºanie co REFRESH_MS ms
    setTimeout(init, REFRESH_MS);
  }

  // Obs≈Çuga przycisku "Od≈õwie≈º"
  document.getElementById('refresh').addEventListener('click', init);

  // Pierwsze wywo≈Çanie
  init();
</script>
</body>
</html>
