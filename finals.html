<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Turniej – Faza Pucharowa</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background: #fafafa; }
    button#refresh { margin-bottom: 10px; padding: 6px 12px; font-size: 1rem; }
    .bracket-container { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 20px; }
    .court { flex: 1; }
    .court h2 { text-align: center; margin-bottom: 10px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: center; }
    th { background: #ddd; }
    tr.phase td { background: #eee; font-weight: bold; }
    tr.women td { background: rgba(255,182,193,0.3); }
    tr.men td   { background: rgba(173,216,230,0.3); }
    tr.break td { background: #f0f0f0; font-weight: bold; }
    .finals { margin-top: 10px; }
    .finals table { width: 100%; }
    .finals th, .finals td { border: 1px solid #ccc; padding: 8px; text-align: center; }
    .finals th { background: #ddd; }
  </style>
</head>
<body>
  <button id="refresh">Odśwież</button>
  <h1 style="text-align:center;">Faza Pucharowa</h1>
  <div id="brackets" class="bracket-container">
    <!-- Boisko A -->
    <div class="court" id="court-A">
      <h2>Boisko A</h2>
      <table>
        <thead>
          <tr><th>Godz.</th><th>Faza</th><th>Zespół A</th><th></th><th>Zespół B</th><th>Wynik</th></tr>
        </thead>
        <tbody id="court-A-body">
          <tr><td colspan="6">Ładowanie...</td></tr>
        </tbody>
      </table>
    </div>

    <!-- Boisko B -->
    <div class="court" id="court-B">
      <h2>Boisko B</h2>
      <table>
        <thead>
          <tr><th>Godz.</th><th>Faza</th><th>Zespół A</th><th></th><th>Zespół B</th><th>Wynik</th></tr>
        </thead>
        <tbody id="court-B-body">
          <tr><td colspan="6">Ładowanie...</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Finały sekcja -->
  <div class="finals">
    <table>
      <thead>
        <tr><th>Godz.</th><th>Faza</th><th>Zespół A</th><th></th><th>Zespół B</th><th>Wynik</th></tr>
      </thead>
      <tbody id="finals-body">
        <tr><td colspan="6">Ładowanie...</td></tr>
      </tbody>
    </table>
  </div>

  <script>
    // co ile ms automatycznie odświeżać:
    const REFRESH_MS = 180000; // 180 000 ms = 3 minuty

    // URL do CSV z arkusza – kolumny E i K, w których wpisujemy wyniki fazy pucharowej:
    const CSV_URL =
      'https://docs.google.com/spreadsheets/d/e/2PACX-1vRHw8kX-ehVxqRrBxKQRAH9EySHdQUfPwWEae-llcCwEp-ba7-Oh82Llo-8rHCszQFJiKC7SZt8KaVg'
      + '/pub?gid=1242680440&single=true&output=csv';

    // Zespoły z fazy grupowej (żeby wytypować półfinalistów):
    const TEAMS = {
      'Mężczyźni': {
        A: ['Gdańsk Bukowski Serwis','Kołobrzeg','Rybnik Team','Poznań Biały'],
        B: ['Zielona Góra','TICINO POLAND','SANICOGOLDLUX','Poznań Niebieski']
      },
      'Kobiety': {
        A: ['KOBIETY NA BOISKA Łódź','Lejdis Wrocław','Basket Team Gdańsk','Twarde Babki Toruń'],
        B: ['Chyże Laski Poznań','Warszawa','Rozważne i Romantyczne Rybnik']
      }
    };

    // Tutaj trzymamy WSZYSTKIE wyniki (grupowe i playoffowe):
    let allResults = [];

    /**
     * Pobiera CSV → zwraca tablicę meczów { teamA, teamB, raw }
     * Gdzie `raw` to “X:Y” tylko wtedy, gdy rzeczywiście słupki E/K mają cyfrę:cyfrę.
     */
    async function fetchResults() {
      const response = await fetch(CSV_URL);
      const text = await response.text();
      const lines = text.trim().split(/\r?\n/);

      const arr = [];
      lines.forEach((line, idx) => {
        if (idx === 0) return; // pomijamy nagłówek CSV

        // Rozbijamy zarówno po przecinku, jak i po średniku (jeśli arkusz generuje średniki):
        const cols = line.split(/,|;/).map(c => c.replace(/^"|"$/g, '').trim());

        // Kolumna E → index 4 (boisko A), Kolumna K → index 10 (boisko B)
        const teamA = cols[1], teamB = cols[3], rawA = cols[4];
        const teamC = cols[7], teamD = cols[9], rawB = cols[10];

        // Jeśli rawA ma postać cyfry:cyfry → to mecz Boisko A
        if (/^\d+:\d+$/.test(rawA) && teamA && teamB) {
          arr.push({ teamA: teamA, teamB: teamB, raw: rawA });
        }
        // Jeśli rawB ma postać cyfry:cyfry → to mecz Boisko B
        if (/^\d+:\d+$/.test(rawB) && teamC && teamD) {
          arr.push({ teamA: teamC, teamB: teamD, raw: rawB });
        }
      });

      allResults = arr; // zapamiętujemy globalnie
      return arr;
    }

    /**
     * Przygotowuje początkowe nawiasy / struktury do liczenia punktów w fazie grup.
     */
    function initStats() {
      const stats = {};
      for (const cat in TEAMS) {
        stats[cat] = {};
        for (const grp in TEAMS[cat]) {
          // Każdy zespół w grupie ma { name, pts, diff }
          stats[cat][grp] = TEAMS[cat][grp].map(name => ({
            name: name,
            pts: 0,
            diff: 0
          }));
        }
      }
      return stats;
    }

    /**
     * Liczy punkty i różnicę TYLKO z fazy grupowej – bo to na ich podstawie wybieramy półfinalistów.
     * W fazie grupowej: zwycięstwo X:Y → 2 pkt, porażka → 1 pkt, diff = suma for − przeciw.
     */
    function computeStats(results) {
      const stats = initStats();
      results.forEach(r => {
        for (const cat in TEAMS) {
          for (const grp in TEAMS[cat]) {
            const list = TEAMS[cat][grp];
            if (list.includes(r.teamA) && list.includes(r.teamB)) {
              const [a, b] = r.raw.split(':').map(Number);
              const A = stats[cat][grp].find(x => x.name === r.teamA);
              const B = stats[cat][grp].find(x => x.name === r.teamB);
              if (A && B) {
                A.pts += (a > b ? 2 : 1);
                B.pts += (b > a ? 2 : 1);
                A.diff += (a - b);
                B.diff += (b - a);
              }
            }
          }
        }
      });
      return stats;
    }

    /**
     * Sortuje tablicę zespołów wg punktów, diff, nazwa.
     */
    function sortTeams(arr) {
      return arr.sort((a, b) => {
        if (b.pts !== a.pts) return b.pts - a.pts;
        if (b.diff !== a.diff) return b.diff - a.diff;
        return a.name.localeCompare(b.name);
      });
    }

    /**
     * Znajduje w allResults rzeczywisty wynik „X:Y” dla pary (teamX vs teamY).
     * Jeśli nie ma jeszcze wpisanego wyniku – zwraca ":".
     */
    function findScore(teamX, teamY) {
      const match = allResults.find(r =>
        (r.teamA === teamX && r.teamB === teamY) ||
        (r.teamA === teamY && r.teamB === teamX)
      );
      if (!match) return ':';
      const [a, b] = match.raw.split(':').map(Number);
      return (match.teamA === teamX) ? `${a}:${b}` : `${b}:${a}`;
    }

    /**
     * Wypełnia tabelki Boisko A, Boisko B i finały na podstawie:
     * 1) wyników fazy grupowej (żeby wytypować półfinalistów),
     * 2) ME tymczasowych placeholderów 4A, 4B, 3A, 3B itd. (dopóki mecz 
     *    nie ma jeszcze wyników, zostaną placeholdery),
     * 3) już gotowych raw-ów meczów półfinałowych / finałowych w allResults.
     */
    function populateCourts(stats) {
      // Posortowane tabele (kobiety A/B i mężczyźni A/B)
      const wA = sortTeams([...stats['Kobiety']['A']]);
      const wB = sortTeams([...stats['Kobiety']['B']]);
      const mA = sortTeams([...stats['Mężczyźni']['A']]);
      const mB = sortTeams([...stats['Mężczyźni']['B']]);

      // Półfinalistki (kobiety)
      const wSF_A = (wA[0]?.pts > 0) ? wA[0].name : '1A';
      const wSF_B = (wB[1]?.pts > 0) ? wB[1].name : '2B';
      const wSF_C = (wB[0]?.pts > 0) ? wB[0].name : '1B';
      const wSF_D = (wA[1]?.pts > 0) ? wA[1].name : '2A';

      // Półfinaliści (mężczyźni)
      const mSF_A = (mA[0]?.pts > 0) ? mA[0].name : '1A';
      const mSF_B = (mB[1]?.pts > 0) ? mB[1].name : '2B';
      const mSF_C = (mB[0]?.pts > 0) ? mB[0].name : '1B';
      const mSF_D = (mA[1]?.pts > 0) ? mA[1].name : '2A';

      // Miejsca 7./5./3.: placeholdery (dopóki wyniku nie ma, zostają 4A, 4B, 3A, 3B, 1A/2B, 1B/2A)
      const p7_A = '4A', p7_B = '4B';
      const p5_A = '3A', p5_B = '3B';
      const p3_A = '1A/2B', p3_B = '1B/2A';

      // Wiersze Boisko A:
      const rowsA = [
        { time:'12:30-13:20', phase:'Półfinał Kobiet',   teamA:wSF_A, teamB:wSF_B, cls:'women' },
        { time:'13:20-14:10', phase:'Półfinał Mężczyzn', teamA:mSF_A, teamB:mSF_B, cls:'men'   },
        { time:'14:10-15:00', phase:'O 7 miejsce',       teamA:p7_A,   teamB:p7_B,   cls:'women' },
        { time:'15:00-15:50', phase:'O 5 miejsce',       teamA:p5_A,   teamB:p5_B,   cls:'men'   },
        { time:'15:50-16:40', phase:'O 3 miejsce',       teamA:p3_A,   teamB:p3_B,   cls:'women' },
        { time:'break',      phase:'PRZERWA TECHNICZNA' }
      ];

      // Wiersze Boisko B:
      const rowsB = [
        { time:'12:30-13:20', phase:'Półfinał Kobiet',   teamA:wSF_C, teamB:wSF_D, cls:'women' },
        { time:'13:20-14:10', phase:'Półfinał Mężczyzn', teamA:mSF_C, teamB:mSF_D, cls:'men'   },
        { time:'14:10-15:00', phase:'O 5 miejsce',       teamA:p5_A,   teamB:p5_B,   cls:'women' },
        { time:'15:00-15:50', phase:'O 3 miejsce',       teamA:p3_A,   teamB:p3_B,   cls:'men'   },
        { time:'break',      phase:'PRZERWA TECHNICZNA' }
      ];

      // Wiersze Finałów (od razu, jeśli wyniki są → wyciąga je, jeśli nie → ":")
      const finalRows = [
        { time:'17:00-17:50', phase:'Finał Kobiet',   teamA:wSF_A, teamB:wSF_B, cls:'women' },
        { time:'17:50-18:40', phase:'Finał Mężczyzn', teamA:mSF_A, teamB:mSF_B, cls:'men'   }
      ];

      // 1) Render Boisko A:
      let htmlA = '';
      rowsA.forEach(r => {
        if (r.time === 'break') {
          htmlA += `<tr class="break"><td colspan="6">${r.phase}</td></tr>`;
        } else {
          const score = findScore(r.teamA, r.teamB);
          htmlA += `<tr class="phase"><td>${r.time}</td><td colspan="4">${r.phase}</td><td></td></tr>`;
          htmlA += `<tr class="${r.cls}"><td></td><td></td><td>${r.teamA}</td><td>vs</td><td>${r.teamB}</td><td>${score}</td></tr>`;
        }
      });
      document.getElementById('court-A-body').innerHTML = htmlA;

      // 2) Render Boisko B:
      let htmlB = '';
      rowsB.forEach(r => {
        if (r.time === 'break') {
          htmlB += `<tr class="break"><td colspan="6">${r.phase}</td></tr>`;
        } else {
          const score = findScore(r.teamA, r.teamB);
          htmlB += `<tr class="phase"><td>${r.time}</td><td colspan="4">${r.phase}</td><td></td></tr>`;
          htmlB += `<tr class="${r.cls}"><td></td><td></td><td>${r.teamA}</td><td>vs</td><td>${r.teamB}</td><td>${score}</td></tr>`;
        }
      });
      document.getElementById('court-B-body').innerHTML = htmlB;

      // 3) Render Finałów:
      let htmlF = '';
      finalRows.forEach(r => {
        const score = findScore(r.teamA, r.teamB);
        htmlF += `<tr class="phase"><td>${r.time}</td><td colspan="4">${r.phase}</td><td></td></tr>`;
        htmlF += `<tr class="${r.cls}"><td></td><td></td><td>${r.teamA}</td><td>vs</td><td>${r.teamB}</td><td>${score}</td></tr>`;
      });
      document.getElementById('finals-body').innerHTML = htmlF;
    }

    /**
     * Główna funkcja inicjalizująca:
     * 1) Czyści placeholdery,
     * 2) Pobiera nowe dane CSV → allResults,
     * 3) Liczy statystyki fazy grupowej → wyłania półfinalistów,
     * 4) Wywołuje populateCourts(stats),
     * 5) Ustawia timeout ponownego uruchomienia init() po 3 minutach.
     */
    async function init() {
      document.getElementById('court-A-body').innerHTML = '<tr><td colspan="6">Ładowanie...</td></tr>';
      document.getElementById('court-B-body').innerHTML = '<tr><td colspan="6">Ładowanie...</td></tr>';
      document.getElementById('finals-body').innerHTML   = '<tr><td colspan="6">Ładowanie...</td></tr>';

      await fetchResults();
      const stats = computeStats(allResults);
      populateCourts(stats);

      setTimeout(init, REFRESH_MS);
    }

    document.getElementById('refresh').addEventListener('click', init);
    init();
  </script>
</body>
</html>
